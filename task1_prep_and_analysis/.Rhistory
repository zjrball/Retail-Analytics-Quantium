# set options for R markdown knitting
# set echo = FALSE to hide code for summary
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
knitr::opts_chunk$set(linewidth=80)
## loading libraries
library(data.table)
library(ggplot2)
library(ggmosaic)
library(readr)
## filepath for datasets
filePath <- "C:/Users/zacan/Desktop/GitHub/Retail-Analytics-Quantium/data"
transactionData <- fread(paste0(filePath,"QVI_transaction_data.csv"))
# set options for R markdown knitting
# set echo = FALSE to hide code for summary
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
knitr::opts_chunk$set(linewidth=80)
# set up line wrapping in MD knit output
library(knitr)
hook_output = knit_hooks$get("output")
knit_hooks$set(output = function(x, options)
{
# this hook is used only when the linewidth option is not NULL
if (!is.null(n <- options$linewidth))
{
x = knitr:::split_lines(x)
# any lines wider than n should be wrapped
if (any(nchar(x) > n))
x = strwrap(x, width = n)
x = paste(x, collapse = "\n")
}
hook_output(x, options)
})
## loading libraries
library(data.table)
library(ggplot2)
library(ggmosaic)
library(readr)
## filepath for datasets
filePath <- "C:/Users/zacan/Desktop/GitHub/Retail-Analytics-Quantium/data"
transactionData <- fread(paste0(filePath,"QVI_transaction_data.csv"))
## loading libraries
library(data.table)
library(ggplot2)
library(ggmosaic)
library(readr)
## filepath for datasets
filePath <- "C:/Users/zacan/Desktop/GitHub/Retail-Analytics-Quantium/data/"
transactionData <- fread(paste0(filePath,"QVI_transaction_data.csv"))
customerData <- fread(paste0(filePath,"QVI_purchase_behaviour.csv"))
# set options for R markdown knitting
# set echo = FALSE to hide code for summary
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
knitr::opts_chunk$set(linewidth=80)
# set up line wrapping in MD knit output
library(knitr)
hook_output = knit_hooks$get("output")
knit_hooks$set(output = function(x, options)
{
# this hook is used only when the linewidth option is not NULL
if (!is.null(n <- options$linewidth))
{
x = knitr:::split_lines(x)
# any lines wider than n should be wrapped
if (any(nchar(x) > n))
x = strwrap(x, width = n)
x = paste(x, collapse = "\n")
}
hook_output(x, options)
})
## loading libraries
library(data.table)
library(ggplot2)
library(ggmosaic)
library(readr)
## filepath for datasets
filePath <- "C:/Users/zacan/Desktop/GitHub/Retail-Analytics-Quantium/data/"
transactionData <- fread(paste0(filePath,"QVI_transaction_data.csv"))
customerData <- fread(paste0(filePath,"QVI_purchase_behaviour.csv"))
## Examine transaction data
head(transactionData)
str(transactionData)
## Convert DATE column to date format
transactionData$DATE <- as.Date(transactionData$DATE,
origin = "1899-12-30")
## Verifying output
str(transactionData)
## Examine PROD_NAME
summary(transactionData$PROD_NAME)
head(transactionData$PROD_NAME)
## Searching for incorrect entries in PROD_NAME
productWords <- data.table(unlist(strsplit(unique
(transactionData[, PROD_NAME])," ")))
setnames(productWords, 'words')
## Removing digits
productWords <- productWords[grepl("\\d", words) == FALSE, ]
## Removing special characters
productWords <- productWords[grepl("[:alpha:]", words), ]
## Looking at most common words by counting the number of times a word appears and sorting them in highest to lowest frequency
productWords[, .N, words][order(N, decreasing = TRUE)]
#### Remove salsa products
transactionData[, SALSA := grepl("salsa", tolower(PROD_NAME))]
transactionData <- transactionData[SALSA == FALSE, ][, SALSA := NULL]
## Summarizing transactionData
summary(transactionData)
## Filtering for 200 packets of chips
transactionData[PROD_QTY >= 200]
## Looking for other transactions by same customer
transactionData[LYLTY_CARD_NBR == 226000, ]
## Removing commercial customer from data
transactionData <- transactionData[!grepl(226000, LYLTY_CARD_NBR)]
## Checking data for any obvious outliers/issues
summary(transactionData)
## Count number of transactions by date
transactionData[, .N, by = DATE]
## Create sequence of dates and join to count of transactions by date
allDates <- data.table(seq(as.Date("2018/07/01"), as.Date("2019/06/30"), by = "day"))
setnames(allDates, "DATE")
transactions_by_day <- merge(allDates, transactionData[, .N, by = DATE], all.x = TRUE)
## Setting plot themes for graphs
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5))
## Plot transactions over time
ggplot(transactions_by_day, aes(x = DATE, y =N)) +
geom_line() +
labs(x = "Day",
y = "Number of transactions",
title = "Transactions over time") +
scale_x_date(breaks = "1 month") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(transactions_by_day[month(DATE) == 12, ], aes(x = DATE, y = N)) +
geom_line() +
labs(x = "Day", y = "Number of transactions", title = "Transactions over
time") +
scale_x_date(breaks = "1 day") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
## Removing Christmas Day outlier in sales and verifying removal
transactionData <- transactionData[!grepl("2018-12-25", DATE)]
transactionData[DATE == "2018-12-25"]
## Creating pack size
transactionData[, PACK_SIZE := parse_number(PROD_NAME)]
## Checking output
transactionData[, .N, PACK_SIZE][order(PACK_SIZE)]
## Checking pack size
head(transactionData, 10)
##  Plotting histogram of pack size
hist(transactionData[, PACK_SIZE])
## Creating brands
transactionData[, BRAND := toupper(substr(PROD_NAME, 1, regexpr(pattern = " ", PROD_NAME) - 1))]
## Checking brands
transactionData[, .N, by = BRAND][order(-N)]
## Cleaning brand names
transactionData[BRAND == "RED", BRAND := "RRD"]
transactionData[BRAND == "SNBTS", BRAND := "SUNBITES"]
transactionData[BRAND == "INFZNS", BRAND := "INFUZIONS"]
transactionData[BRAND == "WW", BRAND := "WOOLWORTHS"]
transactionData[BRAND == "SMITH", BRAND := "SMITHS"]
transactionData[BRAND == "NCC", BRAND := "NATURAL"]
transactionData[BRAND == "DORITO", BRAND := "DORITOS"]
transactionData[BRAND == "GRAIN", BRAND := "GRNWVES"]
transactionData[, .N, by = BRAND][order(BRAND)]
## Examining customer data
str(customerData)
summary(customerData)
## Examining customer data
customerData[, .N, by = LIFESTAGE][order(-N)]
customerData[, .N, by = PREMIUM_CUSTOMER][order(-N)]
## Merge transaction data to customer data
data <- merge(transactionData, customerData, all.x = TRUE)
## checking for any customers not matched
data[is.null(LIFESTAGE), .N]
data[is.null(PREMIUM_CUSTOMER), .N]
# fwrite(data, paste0(filePath,"QVI_data.csv"))
## Total sales by LIFESTAGE and PREMIUM_CUSTOMER
sales <- data[, .(SALES = sum(TOT_SALES)), .(LIFESTAGE, PREMIUM_CUSTOMER)]
## Creating plot
p <- ggplot(data = sales) +
geom_mosaic(aes(weight = SALES, x = product(PREMIUM_CUSTOMER, LIFESTAGE), fill = PREMIUM_CUSTOMER)) +
labs(x = "Lifestage",
y = "Premium Customer Status",
title = "Proportion of Sales") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
## Plot and label with proportion of sales
p + geom_text(data = ggplot_build(p)$data[[1]], aes(x = (xmin + xmax)/2 , y = (ymin + ymax)/2, label = as.character(paste(round(.wt/sum(.wt),3)*100,"%"))),
size = 3)
## Number of customers by LIFESTAGE and PREMIUM CUSTOMER
customers <- data[, .(CUSTOMERS = uniqueN(LYLTY_CARD_NBR)), .(LIFESTAGE, PREMIUM_CUSTOMER)][order(-CUSTOMERS)]
## Creating plot
p <- ggplot(data = customers) +
geom_mosaic(aes(weight = CUSTOMERS, x = product(PREMIUM_CUSTOMER, LIFESTAGE), fill = PREMIUM_CUSTOMER)) +
labs(x = "Lifestage", y = "Premium Customer Status", title = "Proportion of Customers") +
theme(axis.text.x = element_text(vjust = 0.5, hjust = 1, angle = 90))
## Plot and labeling
p + geom_text(data = ggplot_build(p)$data[[1]], aes(x = (xmin + xmax)/2 , y = (ymin + ymax)/2, label = as.character(paste(round(.wt/sum(.wt),3)*100,"%"))),
size = 3)
## Average number of units per customer by LIFESTAGE and PREMIUM CUSTOMER
avg_units <- data[, .(AVG = sum(PROD_QTY)/uniqueN(LYLTY_CARD_NBR)), .(LIFESTAGE, PREMIUM_CUSTOMER)][order(-AVG)]
## Creating plot
ggplot(data = avg_units, aes(weight = AVG, x = LIFESTAGE, fill = PREMIUM_CUSTOMER)) +
geom_bar(position = position_dodge()) +
labs(x = "Lifestage", y = "Average Units Per Transaction", title = "Units per Customer") +
coord_cartesian(ylim = c(3.0,9.5)) +
theme(axis.text.x = element_text(vjust = 0.5, hjust = 1, angle = 90))
## Average price per unit by LIFESTAGE and PREMIUM CUSTOMER
avg_price <- data[, .(AVG = sum(TOT_SALES)/sum(PROD_QTY)), .(LIFESTAGE, PREMIUM_CUSTOMER)][order(-AVG)]
## Creating plot
ggplot(data = avg_price, aes(weight = AVG, x = LIFESTAGE, fill = PREMIUM_CUSTOMER)) +
geom_bar(position = position_dodge()) +
labs(x = "Lifestage", y = "Average Price per Unit", title = "Price per Unit") +
coord_cartesian(ylim = c(3.0, 4.2)) +
theme(axis.text.x = element_text(vjust = 0.5, hjust = 1, angle = 90))
# Perform independent t-test between mainstream vs premium and budget midage and young singles and couples
pricePerUnit <- data[, price := TOT_SALES/PROD_QTY]
t.test(data[LIFESTAGE %in% c("YOUNG SINGLES/COUPLES", "MIDAGE SINGLES/COUPLES") & PREMIUM_CUSTOMER == "Mainstream", price],
data[LIFESTAGE %in% c("YOUNG SINGLES/COUPLES", "MIDAGE SINGLES/COUPLES") & PREMIUM_CUSTOMER != "Mainstream", price], alternative = "greater")
## Deep dive into Mainstream, YOUNG SINGLES/COUPLES
segment1 <- data[LIFESTAGE == "YOUNG SINGLES/COUPLES" & PREMIUM_CUSTOMER == "Mainstream", ]
other <- data[!(LIFESTAGE == "YOUNG SINGLES/COUPLES" & PREMIUM_CUSTOMER == "Mainstream"),]
## Brand affinity
quantity_segment1 <- segment1[, sum(PROD_QTY)]
quantity_other <- other[, sum(PROD_QTY)]
quantity_segment1_by_brand <- segment1[, .(targetSegment = sum(PROD_QTY)/quantity_segment1), by = BRAND]
quantity_other_by_brand <- other[, .(other = sum(PROD_QTY)/quantity_other), by = BRAND]
brand_proportions <- merge(quantity_segment1_by_brand, quantity_other_by_brand)[, affinityToBrand := targetSegment/other]
brand_proportions[order(-affinityToBrand)]
## Preferred pack size compared to rest of population
quantity_segment1_by_pack <- segment1[, .(targetSegment = sum(PROD_QTY)/quantity_segment1), by = PACK_SIZE]
quantity_other_by_pack <- other[, .(other = sum(PROD_QTY)/quantity_other), by = PACK_SIZE]
pack_proportions <- merge(quantity_segment1_by_pack, quantity_other_by_pack)[, affinityToPack := targetSegment/other]
pack_proportions[order(-affinityToPack)]
## 270g pack size
data[PACK_SIZE == 270, unique(PROD_NAME)]
## 220g pack size
data[PACK_SIZE == 220, unique(PROD_NAME)]
